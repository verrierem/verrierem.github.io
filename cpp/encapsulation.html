<!DOCTYPE html>
<html>
  <head>
    <title>Encapsulation</title>
    <meta charset="utf-8"/>
    <link rel="stylesheet" type="text/css" href="../css/main.css"/>
    <link rel="stylesheet" type="text/css" href="../css/hexagone.css"/>
    <link rel="stylesheet" type="text/css" href="../css/custom.css"/>
    <link rel="stylesheet" type="text/css" href="../css/code.css"/>
    <link rel="stylesheet" type="text/css" href="../css/katex.min.css"/>
  </head>
  <body>
    <textarea id="source" readonly>

layout: true
name: tplMain

.footnote[
M. Verrière - École Hexagone - 2025 - [![](../img/home_w.png)](../index.html#1)
]

---
layout: true
name: tplMainTop
template: tplMain
class: top

---
layout: true
name: tplMainMiddle
template: tplMain
class: middle

---
template: tplMainMiddle

# What is encapsulation?

.block[.hcenter.vspace2pc[It consists in hiding the internal, possibly complex, implementation details and only expose the interface.]]


.vspace4pc[
Advantages:
- simplify unit testing,
- avoid antipatterns,
- less bugs, more t(h)rust,
- security: give more control on data usage,
- lead to more accessible code,
- facilitate maintainance,
- make it easier to add new features.
]

---
template: tplMainTop

# Example: Safe pointers in C

.row[
.column.w44[
```c
struct safe_ptr
{
  int *p; // Actual pointer
  int size; // Size of the allocation
};
typedef struct safe_ptr SafePtr;

SafePtr SafePtr_allocate(int size)
{
  int *p = NULL;
  if (size &lt;= 0) return {NULL, 0};
  *p = malloc(size * sizeof(int));
  if (p == NULL) return {NULL, 0};
  return {p, size};
}

void SafePtr_deallocate(SafePtr *ptr)
{
  if (*ptr.p == NULL) return;
  free(*ptr.p);
  *ptr = { NULL, 0 };
}
```
].column.w55[
```c
int SafePtr_isvalid(SafePtr ptr)
{
  return ptr.p != NULL;
}

int SafePtr_get(SafePtr ptr, int index, int *data)
{
  if (!SafePtr_isvalid(ptr)) return 0;
  if (index &lt; 0 && index &gt;= size) return 0;
  *data = ptr[index];
  return 1;
}

int SafePtr_set(SafePtr ptr, int index, int data)
{
  if (!SafePtr_isvalid(ptr)) return 0;
  if (index &lt; 0 && index &gt;= size) return 0;
  ptr[index] = data;
  return 1;
}
```
]]

--

<hr/>

.row[
.column.w49[
```c
/* Safely allocate the ptr */
SafePtr ptr = SafePtr_allocate(8);

/* Safely set the ptr content */
if (!SafePtr_set(ptr, i, 73))
{
  /* Display error and exit */
}
```
].column.w49[
```c
/* Safely get the ptr content */
if (!SafePtr_get(ptr, j, *data))
{
  /* Display error and exit */
}

/* Safely deallocate the ptr */
SafePtr_deallocate(&amp;ptr);
```
]]

---
template: tplMainTop

# Example: Separate headers

.row[
.column.w49[
```cpp
/* Header file MyString.h */

//! Structure representing a safe string.
struct my_string
{
  char *str;  ///&lt; POD string
  int length; ///&lt; size of the string
};
//! Opaque type.
typedef struct my_string MyString;

//! Create an empty MyString.
MyString MyString_create_empty();

//! Concatenate two MyString.

//! \param lhs the left-hand-side
//! \param rhs the right-hand-side
//! \return the concatenation.
MyString MyString_concat(const MyString lhs,
                         const MyString rhs);

//! Concatenate MyString and POD-strings.

//! \param lhs the left-hand-side
//! \param rhs the right-hand-side
//! \return the concatenation.
MyString MyString_concat2(const MyString lhs,
                          const char *rhs);

//! Destroy a MyString
void MyString_destroy(MyString *str);
```
].column.w49[
]]

---
template: tplMainTop

# Example: Separate headers

.row[
.column.w49[
```cpp
/* Header file MyString.h */

//! Structure representing a safe string.
struct my_string
{
  char *str;  ///&lt; POD string
  int length; ///&lt; size of the string
};
//! Opaque type.
typedef struct my_string MyString;

//! Create an empty MyString.
MyString MyString_create_empty();

//! Concatenate two MyString.

//! \param lhs the left-hand-side
//! \param rhs the right-hand-side
//! \return the concatenation.
MyString MyString_concat(const MyString lhs,
                         const MyString rhs);

//! Concatenate MyString and POD-strings.

//! \param lhs the left-hand-side
//! \param rhs the right-hand-side
//! \return the concatenation.
MyString MyString_concat2(const MyString lhs,
                          const char *rhs);

//! Destroy a MyString
void MyString_destroy(MyString *str);
```
].column.w49[
```cpp
/* Implementation file MyString.c */

*#include <MyString.h>

MyString MyString_create_empty()
{
  /* Clever and complex implementation */
}

MyString MyString_concat(const MyString lhs,
                         const MyString rhs)
{
  /* Clever and complex implementation */
}

MyString MyString_concat2(const MyString lhs,
                          const char *rhs)
{
  /* Clever and complex implementation */
}

void MyString_destroy(MyString *str)
{
  /* Clever and complex implementation */
}
```
]]

---
template: tplMainMiddle

# Encapsulation is at the core of the C++ standard library!

Header's name | Main object(s) | Description
--------------- | -------------- | -----------
[iostream](https://en.cppreference.com/w/cpp/header/iostream.html) | `std::cin`, `std::cout`, `std::cerr` | I/O streams
[fstream](https://en.cppreference.com/w/cpp/header/fstream.html) | `std::ifstream`, `std::ofstream` | Read/write files w/ streams
[vector](https://en.cppreference.com/w/cpp/header/vector.html) | `std::vector<T>` | Dynamic size arrays
[map](https://en.cppreference.com/w/cpp/header/map.html) | `std::map<K, T>` | Dictionnaries
[string](https://en.cppreference.com/w/cpp/string/basic_string.html) | `std::string` | Safe strings
[algorithm](https://en.cppreference.com/w/cpp/header/algorithm.html) | e.g., `std::sort()` (many more) | Various standard algorithms
[complex](https://en.cppreference.com/w/cpp/numeric/complex.html) | `std::complex<T>` | Complex numbers
[memory](https://en.cppreference.com/w/cpp/header/memory.html) | e.g.,`std::shared_ptr` (and many more) | Memory tools, smart pointers, ...
... and many more, ([see the full list](https://en.cppreference.com/w/cpp/standard_library.html))

---
template: tplMainTop

# Example of standard library C++ codes
```cpp
#include <vector>

// Initialize a vector with 100 elements, all zeros
std::vector<int> some_squares(100, 0);
int i = 0;
// New form of the `for`-loop
for (int &amp;elem : some_squares)
{
  elem = i * i;
  i += 1;
}
```

--

```cpp
#include <iostream>
#include <string>

std::string lhs = "Hello";
std::string rhs = "World";
std::string concatenation = lhs + ' ' + rhs;
std::cout &lt;&lt; "lhs.size()=" &lt;&lt; lhs.size() &lt;&lt; std::endl;
std::cout &lt;&lt; "rhs.size()=" &lt;&lt; rhs.size() &lt;&lt; std::endl;
std::cout &lt;&lt; "concatenation=" &lt;&lt; concatenation &lt;&lt; std::endl;
```

--

```cpp
#include <map>
#include <string>

std::map<std::string, double> constants;
constants["c"] = 299792458.0; // m/s
constants["h"] = 6.62607015e-34; // J.s
constants["hbar"] = 1.054571818e-34; // J.s

double hbar = constants.at("hbar"); // Set variable hbar to 1.054571818e-34
double G = constants.at("G"); // Throw an exception "std::out_of_range"
```

    </textarea>
    <script src="../javascript/remark.min.js"></script>
    <script src="../javascript/katex.min.js"></script>
    <script src="../javascript/auto-render.min.js"></script>
    <script>
      var slideshow = remark.create({
        highlightStyle: 'monokai',
        countIncrementalSlides: false,
        highlightLines: true,
        highlightSpans: false
      });

      // KaTex rendering
      renderMathInElement(
              document.body,
              {
                      delimiters: [
                              {left: "$$", right: "$$", display: true},
                              {left: "$", right: "$", display: false},
                              {left: "\\(", right: "\\)", display: false}],
                      ignoredTags: []
              });
    </script>
  </body>
</html>
